<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Groups and Monoids · GroupsCore.jl</title><meta name="title" content="Groups and Monoids · GroupsCore.jl"/><meta property="og:title" content="Groups and Monoids · GroupsCore.jl"/><meta property="twitter:title" content="Groups and Monoids · GroupsCore.jl"/><meta name="description" content="Documentation for GroupsCore.jl."/><meta property="og:description" content="Documentation for GroupsCore.jl."/><meta property="twitter:description" content="Documentation for GroupsCore.jl."/><meta property="og:url" content="https://kalmarek.github.io/GroupsCore.jl/groups/"/><meta property="twitter:url" content="https://kalmarek.github.io/GroupsCore.jl/groups/"/><link rel="canonical" href="https://kalmarek.github.io/GroupsCore.jl/groups/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GroupsCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">GroupsCore</a></li><li><span class="tocitem">Basic interface</span><ul><li class="is-active"><a class="tocitem" href>Groups and Monoids</a><ul class="internal"><li><a class="tocitem" href="#Assumptions"><span>Assumptions</span></a></li><li><a class="tocitem" href="#Obligatory-methods"><span>Obligatory methods</span></a></li><li><a class="tocitem" href="#Additional-methods"><span>Additional methods</span></a></li><li><a class="tocitem" href="#Random-elements"><span>Random elements</span></a></li></ul></li><li><a class="tocitem" href="../group_elements/">Group elements</a></li></ul></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basic interface</a></li><li class="is-active"><a href>Groups and Monoids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Groups and Monoids</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/GroupsCore.jl/blob/main/docs/src/groups.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="H1_groups"><a class="docs-heading-anchor" href="#H1_groups">Groups and Monoids</a><a id="H1_groups-1"></a><a class="docs-heading-anchor-permalink" href="#H1_groups" title="Permalink"></a></h1><p>The abstract types <code>Group &lt;: Monoid</code> encompass all <strong>multiplicative groups</strong> and <strong>monoids</strong>. Since these are already abstract, we skip the <code>Abstract</code> prefix.</p><h2 id="Assumptions"><a class="docs-heading-anchor" href="#Assumptions">Assumptions</a><a id="Assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Assumptions" title="Permalink"></a></h2><p><code>GroupsCore</code> implements some methods with default values, which may not be generally true for all groups. The intent is to limit the extent of the required interface. <strong>This requires special care</strong> when implementing groups/monoids that need to override these default methods.</p><p>The methods we currently predefine are:</p><ul><li><p><code>GroupsCore.hasgens(::Monoid) = true</code> This is based on the broad assumption that reasonably generic functions manipulating groups/monoids can be implemented only with an access to a generating set.</p></li><li><p><strong>For finite groups/monoids only</strong> we define <code>Base.length(M) = order(Int, M)</code></p></li></ul><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>In general <code>length</code> should be used <strong>for iteration purposes only</strong>. If you are interested in the number of distinct elements of a groups/monoids, use <a href="../group_elements/#GroupsCore.order-Union{Tuple{T}, Tuple{Type{T}, MonoidElement}} where T"><code>order(::Type{&lt;:Integer}, ::Group)</code></a>. For more information see <a href="#Iteration">Iteration</a>.</p></div></div><h2 id="Obligatory-methods"><a class="docs-heading-anchor" href="#Obligatory-methods">Obligatory methods</a><a id="Obligatory-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Obligatory-methods" title="Permalink"></a></h2><p>Here we list the minimal set of functions that a group object must extend to implement the <code>Monoid</code> interface:</p><ul><li><code>Base.one(::Monoid)</code> and</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GroupsCore.order-Union{Tuple{T}, Tuple{Type{T}, Monoid}} where T" href="#GroupsCore.order-Union{Tuple{T}, Tuple{Type{T}, Monoid}} where T"><code>GroupsCore.order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order([::Type{T} = BigInt, ]M::Monoid) where T</code></pre><p>Return the order of <code>M</code> as an instance of <code>T</code>. If <code>M</code> is of infinite order, <code>GroupsCore.InfiniteOrder</code> exception will be thrown.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Only arbitrary sized integers are required to return a mathematically correct answer.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/af66302e9bb97d396c3a9cb6ff93a53011295a18/src/monoids_groups.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GroupsCore.gens-Tuple{Monoid}" href="#GroupsCore.gens-Tuple{Monoid}"><code>GroupsCore.gens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gens(M::Monoid)</code></pre><p>Return a random-access collection of generators of <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/af66302e9bb97d396c3a9cb6ff93a53011295a18/src/monoids_groups.jl#L35-L38">source</a></section></article><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><p>If a group/monoid is defined by generators (i.e. <code>hasgens(M)</code> returns <code>true</code>) an important aspect of this interface is the iteration over a group.</p><p>Iteration over infinite objects seem to be useful only when the returned elements explore the whole group or monoid. To be precise, for the example of the free group <span>$F_2 = ⟨a,b⟩$</span>, one could implement iteration by sequence</p><p class="math-container">\[a, a^2, a^3, \ldots,\]</p><p>which is arguably less useful than</p><p class="math-container">\[a, b, a^{-1}, b^{-1}, ab, \ldots.\]</p><p>Therefore we put the following assumptions on iteration.</p><ul><li>Iteration is mandatory only if <code>hasgens(M)</code> returns <code>true</code>.</li><li>The first element of the iteration (e.g. given by <code>Base.first</code>) is the group identity.</li><li>Iteration over an infinite group/monoid should exhaust every fixed radius ball around the identity (in word-length metric associated to <code>gens(M)</code>) in finite time.</li><li>There is no requirement that in the iteration sequence elements are returned only once.</li></ul><p>These are just the conventions, the iteration interface consists of standard julia methods:</p><ul><li><a href="https://docs.julialang.org/en/v1/base/collections/#Base.iterate"><code>Base.iterate</code></a></li><li><a href="https://docs.julialang.org/en/v1/base/collections/#Base.eltype"><code>Base.eltype</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IteratorSize-Tuple{Type{&lt;:Monoid}}" href="#Base.IteratorSize-Tuple{Type{&lt;:Monoid}}"><code>Base.IteratorSize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IteratorSize(::Type{M}) where {M &lt;: Monoid}</code></pre><p>Given the type of a monoid, return one of the following values:</p><ul><li><code>Base.IsInfinite()</code> if all instances of groups of type <code>M</code> are infinite.</li><li><code>Base.HasLength()</code> or <code>Base.HasShape{N}()</code> if all instances are finite.</li><li><code>Base.SizeUnknown()</code> otherwise, [the default].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/af66302e9bb97d396c3a9cb6ff93a53011295a18/src/monoids_groups.jl#L68-L74">source</a></section></article><p>In contrast to julia we default to <code>Base.SizeUnknown()</code> to provide a mathematically correct fallback. If a group or monoid is finite by definition, implementing the correct <code>IteratorSize</code> (i.e. <code>Base.HasLength()</code>, or <code>Base.HasShape{N}()</code>) will simplify several other methods, which will be then optimized to work only based on the type of the object. In particular when the information is derivable from the type, there is no need to extend <a href="#Base.isfinite-Tuple{Group}"><code>Base.isfinite</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the case that <code>IteratorSize(Gr) == IsInfinite()</code>, one should could <code>Base.length(Gr)</code> to be a &quot;best effort&quot;, length of the group/monoid iterator. For practical reasons the largest object you could iterate over in your lifetime is of order that fits well into an <code>Int</code> (<span>$2^{63}$</span> nanoseconds comes to 290 years).</p></div></div><h2 id="Additional-methods"><a class="docs-heading-anchor" href="#Additional-methods">Additional methods</a><a id="Additional-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isfinite-Tuple{Group}" href="#Base.isfinite-Tuple{Group}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isfinite(M::Monoid)</code></pre><p>Test whether monoid <code>M</code> is finite.</p><p>The default implementation is based on <code>Base.IteratorSize</code>. Only groups of returning <code>Base.SizeUnknown()</code> should extend this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/af66302e9bb97d396c3a9cb6ff93a53011295a18/src/monoids_groups.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GroupsCore.istrivial-Tuple{Group}" href="#GroupsCore.istrivial-Tuple{Group}"><code>GroupsCore.istrivial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istrivial(M::Monoid)</code></pre><p>Test whether monoid <code>M</code> is trivial.</p><p>The default implementation is based on <code>isfinite</code> and <code>order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/af66302e9bb97d396c3a9cb6ff93a53011295a18/src/monoids_groups.jl#L113-L118">source</a></section></article><h2 id="Random-elements"><a class="docs-heading-anchor" href="#Random-elements">Random elements</a><a id="Random-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Random-elements" title="Permalink"></a></h2><p>We provide two methods for generating random elements of a group or monoid.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GroupsCore.ProductReplacementSampler" href="#GroupsCore.ProductReplacementSampler"><code>GroupsCore.ProductReplacementSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProductReplacementSampler</code></pre><p>Implements Product Replacement Algorithm for a group or monoid generated by an explicit finite set of generators.</p><p>Product Replacement Algorithm performs a random walk on the graph of <code>n</code>-generating tuples of a group (or monoid) with <strong>two accumulators</strong>. Each step consists of</p><ol><li>multiplying the right accumulator by a random generator,</li><li>replacing one of the generators with the product with the right accumulator,</li><li>multiplying the left accumulator (on the left) by a random generator.</li></ol><p>The left accumulator is returned as a random element.</p><p>By default for a group with <code>k</code> generators we set <code>n = 2k + 10</code> and perform <code>10*n</code> scrambling steps before returning a random element.</p><p><code>PRASampler</code> provides provably uniformly distributed random elements for finite groups. For infinite groups <a href="#GroupsCore.RandomWordSampler"><code>RandomWordSampler</code></a> is used.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Using <code>PRASampler</code> for an infinite group is ill-advised as the exponential growth of words during scrambling will result in excessive memory use and out-of-memory situation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/af66302e9bb97d396c3a9cb6ff93a53011295a18/src/rand.jl#L21-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GroupsCore.RandomWordSampler" href="#GroupsCore.RandomWordSampler"><code>GroupsCore.RandomWordSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RandomWordSampler(S, distribution)</code></pre><p>Return elements from a monoid represented by words of length in <code>S</code>, obeying <code>distribution</code>.</p><p>Usually for a monoid (group) <code>S</code> is a (symmetric) generating set.</p><p><code>distribution</code> object must implement <code>cdf(distribution, x::Float64)::Integer</code>.</p><p>For finite monoids or groups when uniformity of results is needed <a href="#GroupsCore.ProductReplacementSampler"><code>ProductReplacementSampler</code></a> should be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/af66302e9bb97d396c3a9cb6ff93a53011295a18/src/rand.jl#L100-L110">source</a></section></article><p>By default for finite monoids <code>ProductReplacementSampler</code> is used and <code>RandomWordSampler</code> following <code>Poisson(λ=8)</code> is employed for inifinite ones.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« GroupsCore</a><a class="docs-footer-nextpage" href="../group_elements/">Group elements »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 19 November 2024 14:20">Tuesday 19 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
