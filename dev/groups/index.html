<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Groups · GroupsCore.jl</title><link rel="canonical" href="https://kalmarek.github.io/GroupsCore.jl/groups/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GroupsCore.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">GroupsCore</a></li><li><span class="tocitem">Basic interface</span><ul><li class="is-active"><a class="tocitem" href>Groups</a><ul class="internal"><li><a class="tocitem" href="#Assumptions"><span>Assumptions</span></a></li><li><a class="tocitem" href="#Obligatory-methods"><span>Obligatory methods</span></a></li></ul></li><li><a class="tocitem" href="../group_elements/">Group elements</a></li></ul></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basic interface</a></li><li class="is-active"><a href>Groups</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Groups</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kalmarek/GroupsCore.jl/blob/master/docs/src/groups.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="H1_groups"><a class="docs-heading-anchor" href="#H1_groups">Groups</a><a id="H1_groups-1"></a><a class="docs-heading-anchor-permalink" href="#H1_groups" title="Permalink"></a></h1><p>The abstract type <code>Group</code> encompasses all groups. Since these are already abstract, we skip the <code>Abstract</code> prefix.</p><h2 id="Assumptions"><a class="docs-heading-anchor" href="#Assumptions">Assumptions</a><a id="Assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Assumptions" title="Permalink"></a></h2><p><code>GroupsCore</code> implement some methods with default values, which may not be generally true for all groups. The intent is to limit the extent of the required interface. <strong>This require special care</strong> when implementing groups that need to override these default methods.</p><p>The methods we currently predefine are:</p><ul><li><code>GroupsCore.hasgens(::Group) = true</code></li></ul><p>This is based on the assumption that reasonably generic functions manipulating groups can be implemented only with access to a generating set.</p><ul><li><strong>For finite groups only</strong> we define <code>Base.length(G) = order(Int, G)</code></li></ul><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>In general <code>length</code> is used <strong>for iteration purposes only</strong>. If you are interested in the number of distinct elements of a group, use <a href="../group_elements/#AbstractAlgebra.Generic.order-Tuple{Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer, AbstractAlgebra.GroupElem}"><code>order(::Type{&lt;:Integer}, ::Group)</code></a>. For more information see <a href="#Iteration">Iteration</a>.</p></div></div><h2 id="Obligatory-methods"><a class="docs-heading-anchor" href="#Obligatory-methods">Obligatory methods</a><a id="Obligatory-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Obligatory-methods" title="Permalink"></a></h2><p>Here we list the minimal set of functions that a group object must extend to implement the <code>Group</code> interface.</p><article class="docstring"><header><a class="docstring-binding" id="Base.one-Tuple{AbstractAlgebra.Group}" href="#Base.one-Tuple{AbstractAlgebra.Group}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">one(G::Group)</code></pre><p>Return the identity element of the group <span>$G$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/6268ae50b15c41a9b65b6d94d2c7728b631eaa2c/src/groups.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.Generic.order-Tuple{Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer, AbstractAlgebra.Group}" href="#AbstractAlgebra.Generic.order-Tuple{Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Integer, AbstractAlgebra.Group}"><code>AbstractAlgebra.Generic.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order(I::Type{Integer} = BigInt, G::Group)</code></pre><p>Return the order of <span>$G$</span> as an instance of <code>I</code>. If <span>$G$</span> is of infinite order, <code>GroupsCore.InfiniteOrder</code> exception will be thrown.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Only arbitrary sized integers are required to return a mathematically correct answer.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/6268ae50b15c41a9b65b6d94d2c7728b631eaa2c/src/groups.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractAlgebra.gens-Tuple{AbstractAlgebra.Group}" href="#AbstractAlgebra.gens-Tuple{AbstractAlgebra.Group}"><code>AbstractAlgebra.gens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gens(G::Group)</code></pre><p>Return a random-access collection of generators of <span>$G$</span>.</p><p>The result of this function is undefined unless <code>GroupsCore.hasgens(G)</code> return <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/6268ae50b15c41a9b65b6d94d2c7728b631eaa2c/src/groups.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.rand(rng::Random.AbstractRNG, rs::Random.SamplerTrivial{Gr}) where {Gr &lt;: Group}</code></pre><p>Return a random group element, treating the group as a collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/6268ae50b15c41a9b65b6d94d2c7728b631eaa2c/src/groups.jl#L53">source</a></section></article><h3 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h3><p>If a group is defined by generators (i.e. <code>hasgens(G)</code> returns <code>true</code>) an important aspect of this interface is the iteration over a group.</p><p>Iteration over infinite objects seem to be useful only when the returned elements explore the whole group. To be precise, for the free group <span>$F_2 = ⟨a,b⟩$</span>, one could implement iteration by sequence</p><p class="math-container">\[a, a^2, a^3, \ldots,\]</p><p>which is arguably less useful than</p><p class="math-container">\[a, b, a^{-1}, b^{-1}, ab, \ldots.\]</p><p>Therefore we put the following assumptions on iteration.</p><ul><li>Iteration is mandatory only if <code>hasgens(G)</code> returns <code>true</code>.</li><li>The first element of the iteration (e.g. given by <code>Base.first</code>) is the group identity.</li><li>Iteration over a finitely generated group should exhaust every fixed radius ball around the identity (in word-length metric) in finite time.</li></ul><p>These are just the conventions, the iteration interface consists of standard julia methods:</p><ul><li><a href="https://docs.julialang.org/en/v1/base/collections/#Base.iterate"><code>Base.iterate</code></a></li><li><a href="https://docs.julialang.org/en/v1/base/collections/#Base.eltype"><code>Base.eltype</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.IteratorSize-Tuple{Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:AbstractAlgebra.Group}" href="#Base.IteratorSize-Tuple{Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:AbstractAlgebra.Group}"><code>Base.IteratorSize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">IteratorSize(::Type{Gr}) where {Gr &lt;: Group}</code></pre><p>Given the type of a group, return one of the following values:</p><ul><li><code>Base.IsInfinite()</code> if all instances of groups of type <code>Gr</code> are infinite.</li><li><code>Base.HasLength()</code> or <code>Base.HasShape{N}()</code> if all instances are finite.</li><li><code>Base.SizeUnknown()</code> otherwise, [the default].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/6268ae50b15c41a9b65b6d94d2c7728b631eaa2c/src/groups.jl#L95">source</a></section></article><p>In contrast to julia we default to <code>Base.SizeUnknown()</code> to provide a mathematically correct fallback. If your group is finite by definition, implementing the correct <code>IteratorSize</code> (i.e. <code>Base.HasLength()</code>, or <code>Base.HasShape{N}()</code>) will simplify several other methods, which will be then optimized to work only based on the type of the group. In particular when the information is derivable from the type, there is no need to extend</p><article class="docstring"><header><a class="docstring-binding" id="Base.isfinite-Tuple{AbstractAlgebra.Group}" href="#Base.isfinite-Tuple{AbstractAlgebra.Group}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isfinite(G::Group)</code></pre><p>Test whether group <span>$G$</span> is finite.</p><p>The default implementation is based on <code>Base.IteratorSize</code>. Only groups of returning <code>Base.SizeUnknown()</code> should extend this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/GroupsCore.jl/blob/6268ae50b15c41a9b65b6d94d2c7728b631eaa2c/src/groups.jl#L128">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the case that <code>IteratorSize(Gr) == IsInfinite()</code>, one should define <code>Base.length(Gr)</code> to be a &quot;best effort&quot;, length of the group iterator.</p><p>For practical reasons the largest group you could iterate over in your lifetime is of order that fits into an <code>Int</code>. For example, <span>$2^{63}$</span> nanoseconds comes to 290 years.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« GroupsCore</a><a class="docs-footer-nextpage" href="../group_elements/">Group elements »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 09:31">Tuesday 13 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
