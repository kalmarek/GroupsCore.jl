var documenterSearchIndex = {"docs":
[{"location":"groups/#H1_groups","page":"Groups and Monoids","title":"Groups and Monoids","text":"","category":"section"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"The abstract types Group <: Monoid encompass all multiplicative groups and monoids. Since these are already abstract, we skip the Abstract prefix.","category":"page"},{"location":"groups/#Assumptions","page":"Groups and Monoids","title":"Assumptions","text":"","category":"section"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"GroupsCore implements some methods with default values, which may not be generally true for all groups. The intent is to limit the extent of the required interface. This requires special care when implementing groups/monoids that need to override these default methods.","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"The methods we currently predefine are:","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"GroupsCore.hasgens(::Monoid) = true This is based on the broad assumption that reasonably generic functions manipulating groups/monoids can be implemented only with an access to a generating set.\nFor finite groups/monoids only we define Base.length(M) = order(Int, M)","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"danger: Danger\nIn general length should be used for iteration purposes only. If you are interested in the number of distinct elements of a groups/monoids, use order(::Type{<:Integer}, ::Group). For more information see Iteration.","category":"page"},{"location":"groups/#Obligatory-methods","page":"Groups and Monoids","title":"Obligatory methods","text":"","category":"section"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Here we list the minimal set of functions that a group object must extend to implement the Monoid interface:","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Base.one(::Monoid) and","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"order(::Type{T}, ::Monoid) where T\ngens(::Monoid)","category":"page"},{"location":"groups/#GroupsCore.order-Union{Tuple{T}, Tuple{Type{T}, Monoid}} where T","page":"Groups and Monoids","title":"GroupsCore.order","text":"order([::Type{T} = BigInt, ]M::Monoid) where T\n\nReturn the order of M as an instance of T. If M is of infinite order, GroupsCore.InfiniteOrder exception will be thrown.\n\nwarning: Warning\nOnly arbitrary sized integers are required to return a mathematically correct answer.\n\n\n\n\n\n","category":"method"},{"location":"groups/#GroupsCore.gens-Tuple{Monoid}","page":"Groups and Monoids","title":"GroupsCore.gens","text":"gens(M::Monoid)\n\nReturn a random-access collection of generators of G.\n\n\n\n\n\n","category":"method"},{"location":"groups/#Iteration","page":"Groups and Monoids","title":"Iteration","text":"","category":"section"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"If a group/monoid is defined by generators (i.e. hasgens(M) returns true) an important aspect of this interface is the iteration over a group.","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Iteration over infinite objects seem to be useful only when the returned elements explore the whole group or monoid. To be precise, for the example of the free group F_2 = ab, one could implement iteration by sequence","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"a a^2 a^3 ldots","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"which is arguably less useful than","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"a b a^-1 b^-1 ab ldots","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Therefore we put the following assumptions on iteration.","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Iteration is mandatory only if hasgens(M) returns true.\nThe first element of the iteration (e.g. given by Base.first) is the group identity.\nIteration over an infinite group/monoid should exhaust every fixed radius ball around the identity (in word-length metric associated to gens(M)) in finite time.\nThere is no requirement that in the iteration sequence elements are returned only once.","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"These are just the conventions, the iteration interface consists of standard julia methods:","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Base.iterate\nBase.eltype","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Base.IteratorSize(::Type{<:Monoid})","category":"page"},{"location":"groups/#Base.IteratorSize-Tuple{Type{<:Monoid}}","page":"Groups and Monoids","title":"Base.IteratorSize","text":"IteratorSize(::Type{M}) where {M <: Monoid}\n\nGiven the type of a monoid, return one of the following values:\n\nBase.IsInfinite() if all instances of groups of type M are infinite.\nBase.HasLength() or Base.HasShape{N}() if all instances are finite.\nBase.SizeUnknown() otherwise, [the default].\n\n\n\n\n\n","category":"method"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"In contrast to julia we default to Base.SizeUnknown() to provide a mathematically correct fallback. If a group or monoid is finite by definition, implementing the correct IteratorSize (i.e. Base.HasLength(), or Base.HasShape{N}()) will simplify several other methods, which will be then optimized to work only based on the type of the object. In particular when the information is derivable from the type, there is no need to extend Base.isfinite.","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"note: Note\nIn the case that IteratorSize(Gr) == IsInfinite(), one should could Base.length(Gr) to be a \"best effort\", length of the group/monoid iterator. For practical reasons the largest object you could iterate over in your lifetime is of order that fits well into an Int (2^63 nanoseconds comes to 290 years).","category":"page"},{"location":"groups/#Additional-methods","page":"Groups and Monoids","title":"Additional methods","text":"","category":"section"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"Base.isfinite(G::Group)\nistrivial(G::Group)","category":"page"},{"location":"groups/#Base.isfinite-Tuple{Group}","page":"Groups and Monoids","title":"Base.isfinite","text":"isfinite(M::Monoid)\n\nTest whether monoid M is finite.\n\nThe default implementation is based on Base.IteratorSize. Only groups of returning Base.SizeUnknown() should extend this method.\n\n\n\n\n\n","category":"method"},{"location":"groups/#GroupsCore.istrivial-Tuple{Group}","page":"Groups and Monoids","title":"GroupsCore.istrivial","text":"istrivial(M::Monoid)\n\nTest whether monoid M is trivial.\n\nThe default implementation is based on isfinite and order.\n\n\n\n\n\n","category":"method"},{"location":"groups/#Random-elements","page":"Groups and Monoids","title":"Random elements","text":"","category":"section"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"We provide two methods for generating random elements of a group or monoid.","category":"page"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"GroupsCore.ProductReplacementSampler\nGroupsCore.RandomWordSampler","category":"page"},{"location":"groups/#GroupsCore.ProductReplacementSampler","page":"Groups and Monoids","title":"GroupsCore.ProductReplacementSampler","text":"ProductReplacementSampler\n\nImplements Product Replacement Algorithm for a group or monoid generated by an explicit finite set of generators.\n\nProduct Replacement Algorithm performs a random walk on the graph of n-generating tuples of a group (or monoid) with two accumulators. Each step consists of\n\nmultiplying the right accumulator by a random generator,\nreplacing one of the generators with the product with the right accumulator,\nmultiplying the left accumulator (on the left) by a random generator.\n\nThe left accumulator is returned as a random element.\n\nBy default for a group with k generators we set n = 2k + 10 and perform 10*n scrambling steps before returning a random element.\n\nPRASampler provides provably uniformly distributed random elements for finite groups. For infinite groups RandomWordSampler is used.\n\nwarning: Warning\nUsing PRASampler for an infinite group is ill-advised as the exponential growth of words during scrambling will result in excessive memory use and out-of-memory situation.\n\n\n\n\n\n","category":"type"},{"location":"groups/#GroupsCore.RandomWordSampler","page":"Groups and Monoids","title":"GroupsCore.RandomWordSampler","text":"RandomWordSampler(S, distribution)\n\nReturn elements from a monoid represented by words of length in S, obeying distribution.\n\nUsually for a monoid (group) S is a (symmetric) generating set.\n\ndistribution object must implement cdf(distribution, x::Float64)::Integer.\n\nFor finite monoids or groups when uniformity of results is needed ProductReplacementSampler should be used.\n\n\n\n\n\n","category":"type"},{"location":"groups/","page":"Groups and Monoids","title":"Groups and Monoids","text":"By default for finite monoids ProductReplacementSampler is used and RandomWordSampler following Poisson(λ=8) is employed for inifinite ones.","category":"page"},{"location":"group_elements/#H1_group_elements","page":"Group elements","title":"Group elements","text":"","category":"section"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"GroupsCore defines abstract types GroupElement <: MonoidElement, which all implementations of group/monoid elements should subtype.","category":"page"},{"location":"group_elements/#Obligatory-methods","page":"Group elements","title":"Obligatory methods","text":"","category":"section"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"parent(::MonoidElement)\n:(==)(::El, ::El) where {El <: MonoidElement}\nisfiniteorder(::MonoidElement)","category":"page"},{"location":"group_elements/#Base.parent-Tuple{MonoidElement}","page":"Group elements","title":"Base.parent","text":"parent(g::MonoidElement)\n\nReturn the parent object of the group element.\n\n\n\n\n\n","category":"method"},{"location":"group_elements/#Base.:==-Union{Tuple{El}, Tuple{El, El}} where El<:MonoidElement","page":"Group elements","title":"Base.:==","text":"==(g::El, h::El) where {El <: MonoidElement}\n\nReturn the best effort equality for monoid elements.\n\nIf ==(g, h) returns truethen the mathematical equalityg == hholds. However==(g, h)may returnfalseeven ifgandh` represent mathematically equal group elements.\n\nFor example, in a finitely presented group, == may return the equality of words.\n\nnote: Note\nThis function may not return due to unsolvable word problem.\n\n\n\n\n\n","category":"method"},{"location":"group_elements/#GroupsCore.isfiniteorder-Tuple{MonoidElement}","page":"Group elements","title":"GroupsCore.isfiniteorder","text":"isfiniteorder(m::MonoidElement)\n\nReturn true if m is of finite order, possibly without computing it.\n\nnote: Note\nIf finiteness of a group or monoid can be decided based on its type there is no need to extend isfiniteorder for its elements.\n\n\n\n\n\n","category":"method"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"As well as the two arithmetic operations:","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"Base.:(*)(::El, ::El) where {El <: MonoidElement}\nBase.inv(::GroupElement)","category":"page"},{"location":"group_elements/#A-note-on-deepcopy","page":"Group elements","title":"A note on deepcopy","text":"","category":"section"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"The elements which are not of isbitstype should extend","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"Base.deepcopy_internal(g::MonoidElement, ::IdDict)","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"according to Base.deepcopy docstring. Due to our assumption on parents of group/monoid elements (acting as local singleton objects), a monoid element and its deepcopy should have identical (i.e. ===) parents.","category":"page"},{"location":"group_elements/#Implemented-methods","page":"Group elements","title":"Implemented methods","text":"","category":"section"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"Using the obligatory methods we implement the rest of the functions in GroupsCore. For starters, the first of these are:","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"Base.one(::MonoidElement)\nBase.:(/)(::El, ::El) where {El <: GroupElement}","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"and","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"order(::Type{T}, ::MonoidElement) where T\nconj\n:(^)(::GEl, ::GEl) where {GEl <: GroupElement}\ncommutator","category":"page"},{"location":"group_elements/#GroupsCore.order-Union{Tuple{T}, Tuple{Type{T}, MonoidElement}} where T","page":"Group elements","title":"GroupsCore.order","text":"order(m::MonoidElement)\norder(::Type{T}, m::MonoidElement) where T\n\nReturn the order of m as an instance of T. If m is of infinite order GroupsCore.InfiniteOrder exception will be thrown.\n\nwarning: Warning\nOnly arbitrary sized integers are required to return a mathematicaly correct answer.\n\n\n\n\n\n","category":"method"},{"location":"group_elements/#Base.conj","page":"Group elements","title":"Base.conj","text":"conj(g::El, h::El) where {El <: GroupElement}\n\nReturn the conjugation of g by h, i.e. inv(h)*g*h.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/#Base.:^-Union{Tuple{GEl}, Tuple{GEl, GEl}} where GEl<:GroupElement","page":"Group elements","title":"Base.:^","text":"^(g::El, h::El) where {El <: GroupElement}\n\nAlias for conj.\n\n\n\n\n\n","category":"method"},{"location":"group_elements/#GroupsCore.commutator","page":"Group elements","title":"GroupsCore.commutator","text":"commutator(g::El, h::El, k::El...) where {El <: GroupElement}\n\nReturn the left associative iterated commutator g h , where g h = g^-1 h^-1 g h.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"Moreover we provide basic implementation which could be altered for performance reasons:","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"Base.:(^)(g::MonoidElement, n::Integer)\nGroups.Core.order([::Type{T}], g::MonoidElement) where T\nBase.hash(::MonoidElement, ::UInt)","category":"page"},{"location":"group_elements/#Mutable-API","page":"Group elements","title":"Mutable API","text":"","category":"section"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"warning: Warning\nWork-in-progress. Mutable API is considered private and hence may change between versions without warning.","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"For the purpose of mutable arithmetic the following methods may be overloaded to provide more tailored versions for a given type and reduce the allocations. These functions should be used when writing libraries, in performance critical sections. However one should only use the returned value and there are no guarantees on in-place modifications actually happening.","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"All of these functions (possibly) alter only the first argument, and must unalias their arguments when necessary.","category":"page"},{"location":"group_elements/","page":"Group elements","title":"Group elements","text":"GroupsCore.one!\nGroupsCore.inv!\nGroupsCore.mul!\nGroupsCore.div_left!\nGroupsCore.div_right!\nGroupsCore.conj!\nGroupsCore.commutator!","category":"page"},{"location":"group_elements/#GroupsCore.one!","page":"Group elements","title":"GroupsCore.one!","text":"one!(m::MonoidElement)\n\nReturn one(m), possibly modifying m.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/#GroupsCore.inv!","page":"Group elements","title":"GroupsCore.inv!","text":"inv!(out::El, g::El) where {El <: GroupElement}\n\nReturn inv(g), possibly modifying out. Aliasing of g with out is allowed.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/#GroupsCore.mul!","page":"Group elements","title":"GroupsCore.mul!","text":"mul!(out::El, g::El, h::El) where {El <: MonoidElement}\n\nReturn g*h, possibly modifying out. Aliasing of g or h with out is allowed.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/#GroupsCore.div_left!","page":"Group elements","title":"GroupsCore.div_left!","text":"div_left!(out::El, g::El, h::El) where {El <: GroupElement}\n\nReturn inv(h)*g, possibly modifying out. Aliasing of g or h with out is allowed.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/#GroupsCore.div_right!","page":"Group elements","title":"GroupsCore.div_right!","text":"div_right!(out::El, g::El, h::El) where {El <: GroupElement}\n\nReturn g*inv(h), possibly modifying out. Aliasing of g or h with out is allowed.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/#GroupsCore.conj!","page":"Group elements","title":"GroupsCore.conj!","text":"conj!(out::El, g::El, h::El) where {El <: GroupElement}\n\nReturn inv(h)*g*h, possibly modifying out. Aliasing of g or h with out is allowed.\n\n\n\n\n\n","category":"function"},{"location":"group_elements/#GroupsCore.commutator!","page":"Group elements","title":"GroupsCore.commutator!","text":"commutator!(out::El, g::El, h::El) where {El <: GroupElement}\n\nReturn inv(g)*inv(h)*g*h, possibly modifying out. Aliasing of g or h with out is allowed.\n\n\n\n\n\n","category":"function"},{"location":"#GroupsCore","page":"GroupsCore","title":"GroupsCore","text":"","category":"section"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"CurrentModule = GroupsCore","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"The aim of this package is to standardize the common assumptions and functions on group i.e. to create Group/Monoid interface.","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"Due to the fact that hardly any information can be encoded in Type, the interface consists of two parts:","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"Group or Monoid (parent object) methods,\nGroupElement or MonoidElement methods.","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"We rely on parent objects that represent groups/monoids, and separate types for elements. It is assumed that all elements of a group or monoid have identical parent (i.e.  ===) so that parent objects behave locally as singletons.","category":"page"},{"location":"#Examples-and-Conformance-testing","page":"GroupsCore","title":"Examples and Conformance testing","text":"","category":"section"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"For an implemented interface please have a look at /test folder, where several example implementations are tested against the conformance test suite:","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"CyclicGroup","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"To test the conformance of e.g. CyclicGroup defined above one can run","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"using GroupsCore\ninclude(joinpath(pathof(GroupsCore), \"..\", \"..\", \"test\", \"conformance_test.jl\"))\ninclude(joinpath(pathof(GroupsCore), \"..\", \"..\", \"test\", \"cyclic.jl\"))\nlet C = CyclicGroup(15)\n    test_GroupsCore_interface(C)\n    # optionally if particular two group elements are to be tested:\n    # g, h = rand(C, 2)\n    # test_GroupsCore_interface(g, h)\n    nothing\nend","category":"page"},{"location":"#Users","page":"GroupsCore","title":"Users","text":"","category":"section"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"PermutationGroups.jl\nGroups.jl,\nSymbolicWedderburn.jl.","category":"page"},{"location":"","page":"GroupsCore","title":"GroupsCore","text":"The Oscar.jl project no longer supports GroupsCore.jl interface at version 0.5. See these comments.","category":"page"},{"location":"extensions/#Extensions","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"The following (empty) functions are defined in GroupsCore only to be extended externally:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"isabelian\nissolvable\nisnilpotent\nisperfect\nderivedsubgroup\ncenter\nsocle\nsylowsubgroup\ncentralizer\nnormalizer\nstabilizer\nright_coset_representatives","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"GroupsCore.index\nGroupsCore.left_coset_representatives","category":"page"},{"location":"extensions/#GroupsCore.index","page":"Extensions","title":"GroupsCore.index","text":"index(H::Gr, G::Gr) where {Gr <: Group}\n\nReturn the index |G : H|, where H ≤ G is a subgroup. If H is not contained in G, an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"extensions/#GroupsCore.left_coset_representatives","page":"Extensions","title":"GroupsCore.left_coset_representatives","text":"left_coset_representatives(H::Gr, G::Gr) where {Gr <: Group}\n\nReturn representatives of the left cosets h G where h are elements of H. If H is not contained in G, an error is thrown.\n\n\n\n\n\n","category":"function"}]
}
